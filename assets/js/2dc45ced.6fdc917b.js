(self.webpackChunkactix_website=self.webpackChunkactix_website||[]).push([[1218],{1838:function(e){e.exports={rustVersion:"1.56",actixWebMajorVersion:"4"}},2400:function(e,t,n){"use strict";n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return d},default:function(){return f},frontMatter:function(){return c},metadata:function(){return u},toc:function(){return h}});var a=n(7462),r=n(3366),s=(n(7294),n(3905)),i=n(3066),o=n(2536),l=n(1838),p=["components"],c={title:"Server"},d="The HTTP Server",u={unversionedId:"server",id:"server",title:"Server",description:"The HttpServer type is responsible for serving HTTP requests.",source:"@site/docs/server.md",sourceDirName:".",slug:"/server",permalink:"/docs/server",draft:!1,editUrl:"https://github.com/actix/actix-website/docs/server.md",tags:[],version:"current",frontMatter:{title:"Server"},sidebar:"docs",previous:{title:"Application",permalink:"/docs/application"},next:{title:"Extractors",permalink:"/docs/extractors"}},m={},h=[{value:"Multi-Threading",id:"multi-threading",level:2},{value:"TLS / HTTPS",id:"tls--https",level:2},{value:"Keep-Alive",id:"keep-alive",level:2},{value:"Graceful shutdown",id:"graceful-shutdown",level:2}],k={toc:h};function f(e){var t=e.components,n=(0,r.Z)(e,p);return(0,s.kt)("wrapper",(0,a.Z)({},k,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"the-http-server"},"The HTTP Server"),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"https://docs.rs/actix-web/4/actix_web/struct.HttpServer.html"},(0,s.kt)("strong",{parentName:"a"},"HttpServer"))," type is responsible for serving HTTP requests."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"HttpServer")," accepts an application factory as a parameter, and the application factory must have ",(0,s.kt)("inlineCode",{parentName:"p"},"Send")," + ",(0,s.kt)("inlineCode",{parentName:"p"},"Sync")," boundaries. More about that in the ",(0,s.kt)("em",{parentName:"p"},"multi-threading")," section."),(0,s.kt)("p",null,"To start the web server it must first be bound to a network socket. Use ",(0,s.kt)("a",{parentName:"p",href:"https://docs.rs/actix-web/4/actix_web/struct.HttpServer.html#method.bind"},(0,s.kt)("inlineCode",{parentName:"a"},"HttpServer::bind()"))," with a socket address tuple or string such as ",(0,s.kt)("inlineCode",{parentName:"p"},'("127.0.0.1", 8080)')," or ",(0,s.kt)("inlineCode",{parentName:"p"},'"0.0.0.0:8080"'),". This will fail if the socket is being used by another application."),(0,s.kt)("p",null,"After the ",(0,s.kt)("inlineCode",{parentName:"p"},"bind")," is successful, use ",(0,s.kt)("a",{parentName:"p",href:"https://docs.rs/actix-web/4/actix_web/struct.HttpServer.html#method.run"},(0,s.kt)("inlineCode",{parentName:"a"},"HttpServer::run()"))," to return a ",(0,s.kt)("a",{parentName:"p",href:"https://docs.rs/actix-web/4/actix_web/dev/struct.Server.html"},(0,s.kt)("inlineCode",{parentName:"a"},"Server"))," instance. The ",(0,s.kt)("inlineCode",{parentName:"p"},"Server")," must be ",(0,s.kt)("inlineCode",{parentName:"p"},"await"),"ed or ",(0,s.kt)("inlineCode",{parentName:"p"},"spawn"),"ed to start processing requests and will run until it receives a shutdown signal (such as, by default, a ",(0,s.kt)("inlineCode",{parentName:"p"},"ctrl-c"),"; ",(0,s.kt)("a",{parentName:"p",href:"#graceful-shutdown"},"read more here"),")."),(0,s.kt)(o.Z,{example:"server",section:"main",mdxType:"CodeBlock"}),(0,s.kt)("h2",{id:"multi-threading"},"Multi-Threading"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"HttpServer")," automatically starts a number of HTTP ",(0,s.kt)("em",{parentName:"p"},"workers"),", by default this number is equal to the number of logical CPUs in the system. This number can be overridden with the ",(0,s.kt)("a",{parentName:"p",href:"https://docs.rs/actix-web/4/actix_web/struct.HttpServer.html#method.workers"},(0,s.kt)("inlineCode",{parentName:"a"},"HttpServer::workers()"))," method."),(0,s.kt)(o.Z,{example:"server",file:"workers.rs",section:"workers",mdxType:"CodeBlock"}),(0,s.kt)("p",null,"Once the workers are created, they each receive a separate ",(0,s.kt)("em",{parentName:"p"},"application")," instance to handle requests. Application state is not shared between the threads, and handlers are free to manipulate their copy of the state with no concurrency concerns."),(0,s.kt)("p",null,"Application state does not need to be ",(0,s.kt)("inlineCode",{parentName:"p"},"Send")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"Sync"),", but application factories must be ",(0,s.kt)("inlineCode",{parentName:"p"},"Send")," + ",(0,s.kt)("inlineCode",{parentName:"p"},"Sync"),"."),(0,s.kt)("p",null,"To share state between worker threads, use an ",(0,s.kt)("inlineCode",{parentName:"p"},"Arc"),"/",(0,s.kt)("inlineCode",{parentName:"p"},"Data"),". Special care should be taken once sharing and synchronization are introduced. In many cases, performance costs are inadvertently introduced as a result of locking the shared state for modifications."),(0,s.kt)("p",null,"In some cases these costs can be alleviated using more efficient locking strategies, for example using ",(0,s.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/sync/struct.RwLock.html"},"read/write locks")," instead of ",(0,s.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/sync/struct.Mutex.html"},"mutexes")," to achieve non-exclusive locking, but the most performant implementations often tend to be ones in which no locking occurs at all."),(0,s.kt)("p",null,"Since each worker thread processes its requests sequentially, handlers which block the current thread will cause the current worker to stop processing new requests:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'fn my_handler() -> impl Responder {\n    std::thread::sleep(Duration::from_secs(5)); // <-- Bad practice! Will cause the current worker thread to hang!\n    "response"\n}\n')),(0,s.kt)("p",null,"For this reason, any long, non-cpu-bound operation (e.g. I/O, database operations, etc.) should be expressed as futures or asynchronous functions. Async handlers get executed concurrently by worker threads and thus don't block execution:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'async fn my_handler() -> impl Responder {\n    tokio::time::sleep(Duration::from_secs(5)).await; // <-- Ok. Worker thread will handle other requests here\n    "response"\n}\n')),(0,s.kt)("p",null,"The same limitation applies to extractors as well. When a handler function receives an argument which implements ",(0,s.kt)("inlineCode",{parentName:"p"},"FromRequest"),", and that implementation blocks the current thread, the worker thread will block when running the handler. Special attention must be given when implementing extractors for this very reason, and they should also be implemented asynchronously where needed."),(0,s.kt)("h2",{id:"tls--https"},"TLS / HTTPS"),(0,s.kt)("p",null,"Actix Web supports two TLS implementations out-of-the-box: ",(0,s.kt)("inlineCode",{parentName:"p"},"rustls")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"openssl"),"."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"rustls")," crate feature is for ",(0,s.kt)("inlineCode",{parentName:"p"},"rustls")," integration and ",(0,s.kt)("inlineCode",{parentName:"p"},"openssl")," is for ",(0,s.kt)("inlineCode",{parentName:"p"},"openssl")," integration."),(0,s.kt)(i.Z,{className:"language-toml",mdxType:"RenderCodeBlock"},'[dependencies]\nactix-web = { version = "'+l.actixWebMajorVersion+'", features = ["openssl"] }\nopenssl = { version = "0.10" }\n'),(0,s.kt)(o.Z,{example:"server",file:"ssl.rs",section:"ssl",mdxType:"CodeBlock"}),(0,s.kt)("p",null,"To create the key.pem and cert.pem use the command. ",(0,s.kt)("strong",{parentName:"p"},"Fill in your own subject")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'$ openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem \\\n  -days 365 -sha256 -subj "/C=CN/ST=Fujian/L=Xiamen/O=TVlinux/OU=Org/CN=muro.lxd"\n')),(0,s.kt)("p",null,"To remove the password, then copy nopass.pem to key.pem"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"$ openssl rsa -in key.pem -out nopass.pem\n")),(0,s.kt)("h2",{id:"keep-alive"},"Keep-Alive"),(0,s.kt)("p",null,"Actix Web keeps connections open to wait for subsequent requests."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("em",{parentName:"p"},"keep alive")," connection behavior is defined by server settings.")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"Duration::from_secs(75)")," or ",(0,s.kt)("inlineCode",{parentName:"li"},"KeepAlive::Timeout(75)"),": enables 75 second keep-alive timer."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"KeepAlive::Os"),": uses OS keep-alive."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"None")," or ",(0,s.kt)("inlineCode",{parentName:"li"},"KeepAlive::Disabled"),": disables keep-alive.")),(0,s.kt)(o.Z,{example:"server",file:"keep_alive.rs",section:"keep-alive",mdxType:"CodeBlock"}),(0,s.kt)("p",null,"If the first option above is selected, then keep-alive is enabled for HTTP/1.1 requests if the response does not explicitly disallow it by, for example, setting the ",(0,s.kt)("a",{parentName:"p",href:"https://docs.rs/actix-web/4/actix_web/http/enum.ConnectionType.html"},"connection type")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"Close")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"Upgrade"),". Force closing a connection can be done with ",(0,s.kt)("a",{parentName:"p",href:"https://docs.rs/actix-web/4/actix_web/dev/struct.HttpResponseBuilder.html#method.force_close"},"the ",(0,s.kt)("inlineCode",{parentName:"a"},"force_close()")," method on ",(0,s.kt)("inlineCode",{parentName:"a"},"HttpResponseBuilder"))),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Keep-alive is ",(0,s.kt)("strong",{parentName:"p"},"off")," for HTTP/1.0 and is ",(0,s.kt)("strong",{parentName:"p"},"on")," for HTTP/1.1 and HTTP/2.0."),(0,s.kt)(o.Z,{example:"server",file:"keep_alive_tp.rs",section:"example",mdxType:"CodeBlock"})),(0,s.kt)("h2",{id:"graceful-shutdown"},"Graceful shutdown"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"HttpServer")," supports graceful shutdown. After receiving a stop signal, workers have a specific amount of time to finish serving requests. Any workers still alive after the timeout are force-dropped. By default the shutdown timeout is set to 30 seconds. You can change this parameter with the ",(0,s.kt)("a",{parentName:"p",href:"https://docs.rs/actix-web/4/actix_web/struct.HttpServer.html#method.shutdown_timeout"},(0,s.kt)("inlineCode",{parentName:"a"},"HttpServer::shutdown_timeout()"))," method."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"HttpServer")," handles several OS signals. ",(0,s.kt)("em",{parentName:"p"},"CTRL-C")," is available on all OSes, other signals are available on unix systems."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},"SIGINT")," - Force shutdown workers"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},"SIGTERM")," - Graceful shutdown workers"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},"SIGQUIT")," - Force shutdown workers")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"It is possible to disable signal handling with ",(0,s.kt)("a",{parentName:"p",href:"https://docs.rs/actix-web/4/actix_web/struct.HttpServer.html#method.disable_signals"},(0,s.kt)("inlineCode",{parentName:"a"},"HttpServer::disable_signals()"))," method.")))}f.isMDXComponent=!0}}]);