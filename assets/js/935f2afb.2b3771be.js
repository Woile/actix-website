"use strict";(self.webpackChunkactix_website=self.webpackChunkactix_website||[]).push([[53],{1109:function(e){e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docs":[{"type":"category","label":"Introduction","items":[{"type":"link","label":"Welcome","href":"/docs/","docId":"welcome"},{"type":"link","label":"What is Actix Web","href":"/docs/whatis","docId":"whatis"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Basics","items":[{"type":"link","label":"Getting Started","href":"/docs/getting-started","docId":"getting-started"},{"type":"link","label":"Application","href":"/docs/application","docId":"application"},{"type":"link","label":"Server","href":"/docs/server","docId":"server"},{"type":"link","label":"Extractors","href":"/docs/extractors","docId":"extractors"},{"type":"link","label":"Handlers","href":"/docs/handlers","docId":"handlers"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Advanced","items":[{"type":"link","label":"Errors","href":"/docs/errors","docId":"errors"},{"type":"link","label":"URL Dispatch","href":"/docs/url-dispatch","docId":"url-dispatch"},{"type":"link","label":"Requests","href":"/docs/request","docId":"request"},{"type":"link","label":"Responses","href":"/docs/response","docId":"response"},{"type":"link","label":"Testing","href":"/docs/testing","docId":"testing"},{"type":"link","label":"Middleware","href":"/docs/middleware","docId":"middleware"},{"type":"link","label":"Static Files","href":"/docs/static-files","docId":"static-files"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Protocols","items":[{"type":"link","label":"Websockets","href":"/docs/websockets","docId":"websockets"},{"type":"link","label":"HTTP/2","href":"/docs/http2","docId":"http2"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Patterns","items":[{"type":"link","label":"Auto-Reloading","href":"/docs/autoreload","docId":"autoreload"},{"type":"link","label":"Databases","href":"/docs/databases","docId":"databases"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Diagrams","items":[{"type":"link","label":"HTTP Server Initialization","href":"/docs/http_server_init","docId":"http_server_init"},{"type":"link","label":"Connection Lifecycle","href":"/docs/conn_lifecycle","docId":"conn_lifecycle"}],"collapsed":true,"collapsible":true},{"type":"category","label":"API Documentation","items":[{"type":"link","label":"actix","href":"https://docs.rs/actix/latest/actix/"},{"type":"link","label":"actix-web","href":"https://docs.rs/actix-web/latest/actix_web/"}],"collapsed":true,"collapsible":true}]},"docs":{"application":{"id":"application","title":"Application","description":"actix-web provides various primitives to build web servers and applications with Rust. It provides routing, middleware, pre-processing of requests, post-processing of responses, etc.","sidebar":"docs"},"autoreload":{"id":"autoreload","title":"Auto-Reloading","description":"During development it can be very handy to have cargo automatically recompile the code on changes. This can be accomplished very easily by using [cargo-watch].","sidebar":"docs"},"conn_lifecycle":{"id":"conn_lifecycle","title":"Connection Lifecycle","description":"After Server has started listening to all sockets, Accept and Worker are two main loops responsible for processing incoming client connections.","sidebar":"docs"},"databases":{"id":"databases","title":"Databases","description":"We have several example projects showing use of async database adapters:","sidebar":"docs"},"errors":{"id":"errors","title":"Errors","description":"Actix Web uses its own actixweb::ResponseError trait for error handling from web handlers.","sidebar":"docs"},"extractors":{"id":"extractors","title":"Extractors","description":"Actix Web provides a facility for type-safe request information access called extractors (i.e., impl FromRequest). There are lots of built-in extractor implementations (see implementors).","sidebar":"docs"},"getting-started":{"id":"getting-started","title":"Getting Started","description":"Installing Rust","sidebar":"docs"},"handlers":{"id":"handlers","title":"Handlers","description":"A request handler is an async function that accepts zero or more parameters that can be extracted from a request (i.e., impl FromRequest) and returns a type that can be converted into an HttpResponse (i.e., impl Responder).","sidebar":"docs"},"http_server_init":{"id":"http_server_init","title":"HTTP Server Initialization","description":"Below is a diagram of HttpServer initialization, which happens on the following code","sidebar":"docs"},"http2":{"id":"http2","title":"HTTP/2","description":"actix-web automatically upgrades connections to HTTP/2 if possible.","sidebar":"docs"},"middleware":{"id":"middleware","title":"Middleware","description":"Actix Web\'s middleware system allows us to add additional behavior to request/response processing. Middleware can hook into an incoming request process, enabling us to modify requests as well as halt request processing to return a response early.","sidebar":"docs"},"request":{"id":"request","title":"Requests","description":"There are several options for json body deserialization.","sidebar":"docs"},"response":{"id":"response","title":"Responses","description":"A builder-like pattern is used to construct an instance of HttpResponse. HttpResponse provides several methods that return a HttpResponseBuilder instance, which implements various convenience methods for building responses.","sidebar":"docs"},"server":{"id":"server","title":"Server","description":"The HttpServer type is responsible for serving HTTP requests.","sidebar":"docs"},"static-files":{"id":"static-files","title":"Static Files","description":"It is possible to serve static files with a custom path pattern and NamedFile. To match a path tail, we can use a [.*] regex.","sidebar":"docs"},"testing":{"id":"testing","title":"Testing","description":"Every application should be well tested. Actix Web provides tools to perform unit and integration tests.","sidebar":"docs"},"url-dispatch":{"id":"url-dispatch","title":"URL Dispatch","description":"URL dispatch provides a simple way for mapping URLs to handler code using a simple pattern matching language. If one of the patterns matches the path information associated with a request, a particular handler object is invoked.","sidebar":"docs"},"websockets":{"id":"websockets","title":"Websockets","description":"Actix Web supports WebSockets with the actix-web-actors crate. It is possible to convert a request\'s Payload to a stream of ws::Payload and then use stream combinators to handle actual messages, but it is simpler to handle websocket communications with an http actor.","sidebar":"docs"},"welcome":{"id":"welcome","title":"Welcome","description":"Guiding you through building web apps with Actix","sidebar":"docs"},"whatis":{"id":"whatis","title":"What is Actix Web","description":"Long ago, Actix Web was built on top of the actix actor framework. Now, Actix Web is largely unrelated to the actor framework and is built using a different system. Though actix is still maintained, its usefulness as a general tool is diminishing as the futures and async/await ecosystem matures. At this time, the use of actix is only required for WebSocket endpoints.","sidebar":"docs"}}}')}}]);